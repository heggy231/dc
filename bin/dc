#!/usr/bin/env ruby
require "dotenv"
require "etc"
require "trollop"

App = Struct.new(:name) do
  def initialize(name: , env: ENV)
    self.name = name.to_s.downcase
  end

  def to_s
    name
  end

  def path
    path = "DC_#{name.upcase}_PATH"
    ENV[path].gsub(/\A~/, HOME)
  end

  def url
    url = "DC_#{name.upcase}_URL"
    ENV[url].gsub(/\A~/, HOME)
  end

  def port
    url[/:(\d+)/, 1]
  end

  def start
    Dir.chdir(path) do
      `#{start_command}`
    end
  end

  def kill
    Dir.chdir(path) do
      `#{kill_command}`
    end
  end

  def pid_file
    "#{path}/tmp/pids/server.pid"
  end

  def pid
    if File.exist?(pid_file)
      File.new(pid_file).read
    end
  end

  def start_command
    [
      "rails server",
      "--port=#{port}",
      "-d",
    ].join(" ")
  end

  def kill_command
    [
      "kill -9",
      pid,
    ].join(" ")
  end
end

curr_dir = Dir.pwd
Dotenv.load

user = Etc.getlogin
HOME = Dir.home(user)

def keys
  urls = ENV.keys.select { |key|
    key.start_with?("DC_") && key.end_with?("_URL")
  }
  urls.map! { |key|
    key[/DC_(.+)_URL/, 1].downcase
  }

  paths = ENV.keys.select { |key|
    key.start_with?("DC_") && key.end_with?("_PATH")
  }
  paths.map! { |key|
    key[/DC_(.+)_PATH/, 1].downcase
  }

  a, b = urls, paths
  (a+b).uniq - ((a-b) + (b-a))
end


require 'trollop'
OPTIONS = Trollop::options do
  # General actions
  opt :start,   "Start apps", short: :s
  opt :kill,    "Kill apps", short: :k
  opt :restart, "Kill and Restart apps", short: :r

  # Information
  opt :paths, "Print paths", short: :p
  opt :urls,  "Print urls", short: :u
  opt :dry,   "Dry Run"

  # # Database
  # opt :dbrecreate, "Recreate Database", short: :m
  # opt :dbmigrate,  "Migrate Database"
  # opt :dbseed,     "Seed Database"
  # opt :dbdrop,     "Drop Database"
end

def apps
  @app_names = ARGV.any? ? ARGV : keys
  @app_names.map!(&:downcase)

  if OPTIONS[:dbrecreate] || OPTIONS[:dbmigrate] || OPTIONS[:dbseed]
    @app_names = [ENV["DC_DB_APP"]]
  end

  if @app_names.all? { |name| keys.include?(name) }
    @app_names.map { |name| App.new(name: name) }
  else
    @app_names.each do |name|
      unless keys.include?(name)
        puts "Invalid App name: #{name}"
      end
    end
    exit(1)
  end
end

max_name_length = apps.max { |a, b| a.name.size <=> b.name.size }.name.size

apps.each do |app|
  if OPTIONS[:kill] || OPTIONS[:restart] || OPTIONS[:dbrecreate] || OPTIONS[:dbmigrate]
    app.kill
    puts "Stopping #{app}"
  end

  if OPTIONS[:start] || OPTIONS[:restart] || OPTIONS[:dbrecreate] || OPTIONS[:dbmigrate]
    app.start
  end

  if OPTIONS[:urls] || OPTIONS[:start] || OPTIONS[:restart]
    puts "%#{max_name_length}s: %s" % [app, app.url]
  end

  if OPTIONS[:paths]
    puts "%#{max_name_length}s: %s" % [app, app.path]
  end
end
